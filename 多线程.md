   ## 1.线程创建与结束：
```c
int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);
```
    第一个参数：指向线程标识符的指针；第二个参数：设置线程属性；第三个参数：线程运行函数的起始地址；第四个参数：运行函数的参数。
    返回值：如线程创建成功，返回0；否则返回出错编号
    
### 关于第三个参数：线程的运行函数
**返回通用指针，输入通用指针**
- 运行函数的传入参数为NULL<br>
[见9.1.cpp](https://github.com/liuchenjane/Advanced-Programming-in-the-UNIX-Environment/blob/master/pthread9.1.cpp)<br>
`int iRet = pthread_create(&tid, NULL, say_hello, NULL);`
- 传入类的成员函数为类的成员函数<br>
[见9.2.cpp](https://github.com/liuchenjane/Advanced-Programming-in-the-UNIX-Environment/blob/master/pthread9.2.cpp)<br>
**注意：传入的类成员函数必须是静态的**<br>
>因为：类的非静态成员函数会在参数列表中包含this指针，这与要求的通用指针`void *`不符。<br>

` int iRet = pthread_create(&tid, NULL, Hello::say_hello, NULL);`
- 运行函数的传入参数为int<br>
[见9.3.cpp](https://github.com/liuchenjane/Advanced-Programming-in-the-UNIX-Environment/blob/master/pthread9.3.cpp)<br>
`int iRet = pthread_create(&tid, NULL, say_hello, &para);`
- 传递一个以上参数，应用结构体<br>
[见9.4.cpp](https://github.com/liuchenjane/Advanced-Programming-in-the-UNIX-Environment/blob/master/pthread9.4.cpp)<br>
int iRet = pthread_create(&tid, NULL, say_hello, &arg_temp);

### 线程结束
- 函数已经结束，调用它的线程即结束<br>
- 子线程调用`void pthread_exit (void *retval)`结束当前进程<br>

### 获得线程id<br>
[见9.6.cpp](https://github.com/liuchenjane/Advanced-Programming-in-the-UNIX-Environment/blob/master/pthread9.6.cpp)<br>
- 使用函数pthread_self()<br>
- 创建时生成id

---
## 2. 线程的属性 <br>
     线性属性结构：
```c
typedef struct{
   int etachstate;   //线程的分离状态
   int schedpolicy;
   struct sched_param shedparam;
   int scope;
   size_t guardsize;
   int stackaddr_set;
   void * stackaddr;
   size_t stacksize;
}pthread_attr_t;
```

默认线程属性：非绑定、非分离、默认1MB大小堆栈、与父进程同样级别优先级<br>

- 分离状态<br>
若线程终止时，线程处于分离状态，系统将不保留线程终止状态<br>
[9.7.cpp](https://github.com/liuchenjane/Advanced-Programming-in-the-UNIX-Environment/blob/master/pthread9.7.cpp):
在线程创建属性里指定状态为分离状态<br>
```c
int pthread_attr_setdetachstate(const pthread_attr_t *attr, int *state)
```
属性设置为`PTHREAD_CREATE_DETACHED`（分离），另一状态：`PTHREAD_CREATE_JOINABLE`<br>
[9.8.cpp](https://github.com/liuchenjane/Advanced-Programming-in-the-UNIX-Environment/blob/master/pthread9.8.cpp):
分离一个已经创建的线程<br>
通过函数`pthread_detached(tid)`<br>

---
## 3. 多线程同步
[9.9.cpp模拟售票系统](https://github.com/liuchenjane/Advanced-Programming-in-the-UNIX-Environment/blob/master/pthread9.9.cpp)<br>
运行结果：售票总数大于实际的票数，根本原因：同时发生的各个线程都可以对total_ticket_num读和写。<br>
**竞争资源问题：解决竞争条件方法是将原先分离的两个指令构成不可分割的原子操作，其他任务不能插入到原子操作中。**<br>
>同步：在一定时间内只允许某一个线程访问资源。<br>

- 互斥锁：<br>
互斥锁一般被设置为全局变量，只有lock和unlock两种状态。<br>
打开的互斥锁可以由某个线程获得。一旦获得，互斥锁会锁上，只有该线程有权打开，其他想要获得互斥锁的线程，需等待锁再次打开。<br>
```c
pthread_mutex_t mutex_x= PTHREAD_MUTEX_INITIALIZER; //静态创建锁
int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr);//动态创建
int pthread_mutex_lock(pthread_mutex_t *mutex);//加锁
int pthread_mutex_unlock(pthread_mutex_t *mutex);//解锁
int pthread_mutex_trylock(pthread_mutex_t * mutex);//测试加锁

```
